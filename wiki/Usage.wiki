#summary How to Use the PinChangeInt Library
#labels Featured,Phase-Implementation

=Introduction=

How to use the PinChangeInt library in your own programs.  Here I assume you have properly installed the library.  See the Installation wiki page for more information.

In general, I am writing this for version 1.3 and above of the PinChangeInt library, but most things will apply to earlier versions as well.
=Overview=
==The Quick and Dirty Method==
In your sketch, include:
{{{
#include <PinChangeInt.h>
}}}
Create a quick function that the library will call whenever your pin(s) are interrupted:
{{{
uint8_t latest_interrupted_pin;
uint8_t interrupt_count[20]={0}; // 20 possible arduino pins
void quicfunc() {
  latest_interrupted_pin=PCintPort::arduinoPin;
  interrupt_count[latest_interrupted_pin]++;
}
}}}
Decide if you want to interrupt on RISING, FALLING, or CHANGE of signal.  In `setup()`, attach an interrupt to your pin.  Here, we attach to pin 2:
{{{
PCintPort::attachInterrupt(2, &quicfunc, CHANGE);
}}}
In this case, whenever pin 2 changes, `quicfunc()` will get called, and variable `latest_interrupted_pin` will be set to `2`.  Your `loop()` can poll `latest_interrupted_pin` whenever it wants.  `quicfunc()` can be more elaborate, but it should be quick because it is called by an interrupt.
{{{
setup() {
  Serial.begin(115200);
  Serial.println("---------------------------------------");
}

uint8_t i;
loop() {
  for (i=0; i < 20; i++) {
    if (interrupt_count[i] != 0) {
      count=interrupt_count[i];
      interrupt_count[i]=0;
      Serial.print("Count for pin ");
      if (i < 14) {
        Serial.print("D");
        Serial.print(i, DEC);
      } else {
        Serial.print("AI");
        Serial.print(i-14, DEC);
      }
      Serial.print(" is ");
      Serial.println(count, DEC);
    }
  }
}
}}}
==Reference==
===Public Methods===
{{{
void attachInterrupt(uint8_t pin, void *userFunc, int mode)
}}}
Attaches an interrupt to the given pin.  The interrupt will call the function `userFunc`, based on the `mode`.  The arguments are:
  * `pin` - The pin on the Arduino that you want to attach an interrupt to.
  * `userFunc` - A user-defined function that the interrupt routine will call.
  * `mode` - The interrupt will trigger based on `mode`, which can be one of *RISING*, *FALLING*, or *CHANGE*
{{{
void detachInterrupt(uint8_t pin)
}}}
Stops interrupting on the given pin.
{{{
static uint8_t arduinoPin
}}}
This variable is assigned the value of the latest pin that caused an interrupt.  This pin will be correct for the current run of the `userFunc`.  Once `userFunc` has exited, another interrupt is free to update this variable, so expect it to change.
===The PinChangeIntConfig.h file===
There are a small number of parameters that the programmer can modify to limit the amount of memory the library uses.  These parameters _*must*_ be set in the `PinChangeIntConfig.h` file.  They will have no effect if set anywhere else, including your sketch.  Trust me on this one:  You must go to the libraries directory, and edit this config file itself for it to be of use.

That said, I yearn to get rid of these parameters.  So far, I have not found anyone that really uses them (including myself), and I have seen some examples where the programmer didn't set them properly.  So I consider this file somewhat broken.  But not TOO broken, because the fix requires dynamic data structures which could affect speed of the interrupt routine.  That's no good.  But then again, if speed was *that* critical, you'd be programming in assembly, wouldn't you?  :-)
===`PinChangeIntConfig.h`:MAX_PIN_CHANGE_PINS===
====Limit on the Number of Pins====
In versions prior to and including 1.2 of the library, the variable MAX_PIN_CHANGE_PINS was used to limit memory usage.  As of version 1.3 this variable is no longer used, as pins are added dynamically.
===`PinChangeIntConfig.h`:Memory Utilization===
There are 3 #define's in the `PinChangeIntConfig.h` file that control how many interrupt vectors are enabled:
{{{
//#define       NO_PORTB_PINCHANGES
//#define       NO_PORTC_PINCHANGES
//#define       NO_PORTD_PINCHANGES
}}}
The corresponding code looks like this:
{{{
#ifndef NO_PORTB_PINCHANGES
ISR(PCINT0_vect) {
    PCintPort::pcIntPorts[0].PCint();
}
#endif
}}}
So if you know, for example, that you have only pins on PORTB, you can uncomment the lines as follows:
{{{
//#define       NO_PORTB_PINCHANGES
#define       NO_PORTC_PINCHANGES
#define       NO_PORTD_PINCHANGES
}}}
This will not set up the corresponding interrupt vectors and it will inline the single remaining interrupt routine.  I have not measured the effect on interrupt routine speed.

===`PinChangeIntConfig.h`:DISABLE_PCINT_MULTI_SERVICE===
For servicing multiple interrupts.

Normally, the PinChangeInt interrupt routine will attempt to handle all changed pins on a port.  This can alleviate the overhead to enter and exit the interrupt routine.  However, if you don't want this- for example, with rapid interrupts your CPU may never exit the interrupt routine- then you can uncomment the `DISABLE_PCINT_MULTI_SERVICE` line in the `PinChangeIntConfig.h` file:
{{{
#define       DISABLE_PCINT_MULTI_SERVICE
}}}

===More Information===
See the [http://code.google.com/p/arduino-pinchangeint/wiki/Logic Logic] wiki page in this project for more detailed information about the operation of this library.
=Examples=
Here is an example with a pushbutton connected to pin2 and another to pin3.  One side of the pushbutton is connected to ground.  The other side connects to the Arduino pin.
{{{
#include <PinChangeInt.h>

// These two pins are connected for interrupts.
// Add more Pins at your leisure.
// For the Analog Input pins, you can use 14, 15, 16, etc.
// or you can use A0, A1, A2, etc.  The Arduino code comes with #define's
// for the Analog Input pins.
#define PIN1 2
#define PIN2 3

uint8_t latest_interrupted_pin;
uint8_t interrupt_count[20]={0}; // 20 possible arduino pins
void quicfunc() {
  latest_interrupted_pin=PCintPort::arduinoPin;
  interrupt_count[latest_interrupted_pin]++;
};

void setup() {
  pinMode(PIN1, INPUT); digitalWrite(PIN1, HIGH);
  PCintPort::attachInterrupt(PIN1, &quicfunc, FALLING);  // add more attachInterrupt code as required
  pinMode(PIN2, INPUT); digitalWrite(PIN2, HIGH);
  PCintPort::attachInterrupt(PIN2, &quicfunc, FALLING);
  Serial.begin(115200);
  Serial.println("---------------------------------------");
}

uint8_t i;
void loop() {
  uint8_t count;
  Serial.print(".");
  delay(1000);
  for (i=0; i < 20; i++) {
    if (interrupt_count[i] != 0) {
      count=interrupt_count[i];
      interrupt_count[i]=0;
      Serial.print("Count for pin ");
      if (i < 14) {
        Serial.print("D");
        Serial.print(i, DEC);
      } else {
        Serial.print("A");
        Serial.print(i-14, DEC);
      }
      Serial.print(" is ");
      Serial.println(count, DEC);
    }
  }
}
}}}