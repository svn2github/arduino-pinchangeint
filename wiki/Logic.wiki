#summary Theory of Operation for this Library.
#labels Featured,Phase-Design

= Introduction =

The ATmega328p has two different kinds of interrupts: “external”, and “pin change”.  There are only two external interrupt pins, INT0 and INT1, and they are mapped to Arduino pins 2 and 3.  These interrupts can be set to trigger on RISING or FALLING signal edges, or on low level.  On the other hand the pin change interrupts can be enabled on any or all of the Arduino's signal pins.  They are triggered equally on RISING or FALLING signal edges, so it is up to the interrupt code to determine what happened (did the signal rise, or fall?) and handle it properly.  Furthermore, the pin change interrupts are grouped into 3 “port”s on the MCU, so there are only 3 interrupt vectors (subroutines) for the entire body of 19 pins.  This makes the job of resolving the action on a single interrupt even more complicated.  The interrupt routine should be fast, but complication is the enemy of speed.

The PinChangeInt library is designed to handle the Arduino's pin change interrupts.  This is a description of how the ATmega328p Pin Change Interrupts work, and how the PinChangeInt library handles the situation.

Note that the theory is similar for the ATmega2560.  The ATmega2560 has more External Interrupts, but its PinChange Interrupts are enabled on a different set of its ports: Ports B, J, and K.

= Details =
== ATmega328p Pins and Ports ==
The Arduino's pins are shown below, in parentheses.  The corresponding pin numbers on the ATmega 328p are shown alongside the diagram of the 28-pin dip package:
{{{
                  +-\/-+
            PC6  1|    |28  PC5 (AI 5)
      (D 0) PD0  2|    |27  PC4 (AI 4)
      (D 1) PD1  3|    |26  PC3 (AI 3)
      (D 2) PD2  4|    |25  PC2 (AI 2)
 PWM+ (D 3) PD3  5|    |24  PC1 (AI 1)
      (D 4) PD4  6|    |23  PC0 (AI 0)
            VCC  7|    |22  GND
            GND  8|    |21  AREF
            PB6  9|    |20  AVCC
            PB7 10|    |19  PB5 (D 13)
 PWM+ (D 5) PD5 11|    |18  PB4 (D 12)
 PWM+ (D 6) PD6 12|    |17  PB3 (D 11) PWM
      (D 7) PD7 13|    |16  PB2 (D 10) PWM
      (D 8) PB0 14|    |15  PB1 (D 9) PWM
                  +----+
}}}

Refer to the pin chart at http://www.arduino.cc/en/Hacking/PinMapping168, reproduced above.

The ATmega328 and its kind (ATmega168, ATmega2560) all use PORTs for their input and outputs.  A PORT is essentially a group of pins on the ATmega processor.  They are interesting because the pins grouped in each PORT share some things in common.  For example, you can read all the pins in a PORT in one command.

How do you know which pins are common with which PORTs?  Look at the pin mapping diagram as given in the link or shown above.  The pin names closest to the IC chip:  ie, PD0, PD1, PB6, etc., show you the PORTs.  B, C, and D are the three PORTs available on the ATmega168 and 328.  There are more PORTs on the ATmega2560 used in the Arduino Mega, but only those 3 PORTs allow for Pin Change interrupts on those bigger chips, too.

This is a summary of the Arduino-to-port mappings that are available to you:
{{{
 Arduino Pins         PORT
 ------------         ----
 Digital 0-7          D
 Digital 8-13         B
 Analog  0-5          C
}}}

Why is this important?  It may not be, for you.  This came up when I was programming my AdaEncoder library (http://code.google.com/p/adaencoder/), because when an encoder triggered an interrupt I needed to query the status of both pins on an encoder in order to know what state the device was in.  The easiest thing to do was to query the PORT state register.

==ATMega328p Pin Change Interrupts==
===Enabling===
In order to enable an Interrupt on any of the Arduino pins using the Pin Change Interrupts, you need to do the following:
  # Enable interrupts on the pin's Port by setting the proper bit in the PCICR register.
  # Enable each pin for interrupts that you care to, by setting the appropriate PCMSK0, PCMSK1, or PCMSK2 register with the bit position of the corresponding pin.  PCMSK0 corresponds to PORT B, PCMSK1 corresponds to PORT C, and PCMSK2 corresponds to PORT D.
*Assuming* that interrupts have not been disabled, that's it.  The ATmega328p will trigger an interrupt on any CHANGE (transition from high to low or low to high voltage) on any enabled input pin on that port.  Each PORT has a single interrupt vector corresponding to it.  This means that if pin 8 and pin 9 both are enabled for interrupts, then the ATmega328p calls the interrupt routine pointed to by the PCINT0_vect vector because pins 8 and 9 share PORT B.

Note that enabling interrupts globally is as simple as setting the Global Interrupt Enable flag, which is bit 7 of the Status Register (SREG).  This bit is enabled by default.  Also interesting is that the flag is cleared by hardware as soon as an interrupt takes place, and it's set by the Return from Interrupt instruction when the Interrupt routine returns.  It is possible for an interrupt to set this flag, thereby enabling nested interrupts.  This is not done by the PinChangeInt library- that is, nested interrupts are not enabled under the covers.

===Priority===
Here is the beginning of Table 11-1 from the ATmega328p datasheet (http://www.atmel.com/dyn/resources/prod_documents/doc8025.pdf).  It shows the priorities of all the interrupts on the computer.  Note that the Pin Change Interrupt interrupts are quite high priority.  If you do not use the external interrupts, then they are second only to the reset signal.  Note, too, that pins set up on PORTB will have a higher interrupt priority than PORT C, which is higher than PORT D. 
{{{
Vector No.	Program Address	Source	Interrupt Definition
1		0x000		RESET	External Pin, Power-on Reset, Brown-out Reset and Watchdog System Reset
2		0x001		INT0	External Interrupt Request 0
3		0x002		INT1	External Interrupt Request 1
4		0x003		PCINT0	Pin Change Interrupt Request 0
5		0x004		PCINT1 	Pin Change Interrupt Request 1
6		0x005		PCINT2	Pin Change Interrupt Request 2
}}}
==PinChangeInt Details==
Here is how the library sets up the interrupts, and how it handles them once a pin is interrupted.  This discussion refers to version 1.70beta of the PinChangeInt library.  Get it from the Downloads section of this Project.
===Setting Up the Ports===
For each port that you have *not* `#define`d `NO_PORTX_CHANGES` for, an object is created that represents the port in software.  Stripped to its bare essentials and ignoring the `#define` macros that enable you to disable certain features, the port class (from whence the port objects come) looks like this:
{{{
class PCintPort {
public:
        volatile        uint8_t&                portInputReg;
        static          void attachInterrupt(uint8_t pin, PCIntvoidFuncPtr userFunc, int mode);
        static          void detachInterrupt(uint8_t pin);
        static  uint8_t curr;
        static  uint8_t arduinoPin;
        static  uint8_t pinState;
        static uint8_t pinmode;
protected:
        class PCintPin {
        public:
                PCIntvoidFuncPtr PCintFunc;
                uint8_t         mode;
                uint8_t         mask;
                uint8_t arduinoPin;
                PCintPin* next;
        };
        void            addPin(uint8_t arduinoPin,uint8_t mode,PCIntvoidFuncPtr userFunc);
        void            delPin(uint8_t mask);
        volatile        uint8_t&                portPCMask;
        const           uint8_t                 PCICRbit;
        uint8_t         lastPinView;
        PCintPin*       createPin(uint8_t arduinoPin, uint8_t mode);
        PCintPin*       firstPin;
};
}}}
Here is what each element is for:
{{{
class PCintPort {
public:
123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
portInputReg: This is a reference to the memory-mapped address of the register which,
	when read, will give you the status of all the pins on that port.
attachInterrupt: This is a static method which means its roughly akin to a C function:
	it is a method that can be utilized outside the scope of the class PCintPort.
	And this means that your sketch can call it like this:
		PCintPort::attachInterrupt(arguments...).
	This is the grandaddy method that attaches an interrupt to a pin.
detachInterrupt: The converse of attachInterrupt(), this detaches an interrupt from a pin.
	Similar in that it is called like:
		PCintPort::detachInterrupt(argument)
curr: The current value of the PORT upon which an interrupt took place.  This is read as
	soon as possible in the interrupt handler, as there is a small but finite time
	between when an interrupt takes place and when the handler is able to run.
arduinoPin: The current arduino pin upon which an interrupt took place.  Its value will
	be from 0 to 19.  A0 through A5 are equivalent to 14 through 19.  This is a
	static variable shared by all instances of PCintPort, because there is only
	arduino pin that we will be handling in any instance.
pinState:  The current state of the pin that interrupted us: either HIGH or LOW.  This
	is static as well for the reason given above.
pinmode: The mode you have defined for the curret pin.  This is static as well for the
	reason given above.

The following members are protected; that is, they are only available within objects of
type PCintPort, or subclasses of the object (there are no subclasses defined in the
PCintPort library).

class PCintPin: This class represents any given pin on the port.  It is comprised of:
   PCintFunc: a pointer to the interrupt handler you want to call.
   mode: the pin s mode.
   mask: the bitmask of the pin on the port.  Each pin on a port is represented in one of
	the bits of a register byte.  The mask is simply the bit that is set in the
	proper position for that pin on that port.
   arduinoPin: the arduino pin number for this PCintPin object.
   next: The PCintPins are organized as a linked list attached to the PCintPort.  This
	points to the next pin in the list; if the last, then it points to NULL.

123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
The rest of the protected PCintPort entries follow:

addPin: the method that adds a pin to a port.
delPin: the method that removes a pin from a port.
portPCMask: this is a reference to a register which indicates by bit position which pin
	on a port is enabled for interrupts.  That is, a pin with a 1 bit in the proper
	position in this byte will interrupt the processor.  A pin with a 0 bit in the
	proper position will not interrupt.
PCICRbit: Represents the bit in the Pin Change Interrupt Control Register (PCICR) that
	will turn interrupts on for a port.  If the bit in the proper position of the
	PCICR is 1, the port will interrupt if one of its enabled bins changes.  If the
	bit is 0, none of the pins will trigger an interrupt, no matter what the setting
	of the portPCMask.  There are only 3 bit positions used on the ATmega328's PCICR,
	because there are only 3 ports on the processor.
lastPinView: This state of the pin register at interrupt.  But this is first checked
	against PCintPort::curr to see which pin(s) triggered our current interrupt, then
	it is set to PCintPort::curr.  The difficult question is, how do the pins look in
	an uninterrupted state?  In order to properly gain the first interrupt the values
	of the uninterrupted pins must be known.  Because if the port is checked at
	initialization, who s to say that the pins are in the interrupted or uninterrupted
	state?  This makes the very first interrupt on a pin suspect.  Maybe we actually
	missed the first one.  Maybe we are interrupted and there wasn't really an
	interrupt.  The easy out that I took was to initially just set lastPinView to be
	the state of the port at construction time.
createPin: a helper function for addPin().  This is where the PCintPin object is created
	and filled in.
firstPin: the pointer to the first PCintPin of the port.
};
}}}
===Enabling a Pin===
===Responding to an Interrupt===
===Disabling a Pin===
===A===
===A===
===A===
_to be continued_